import {
  JobNode,
  PipelineNode,
  TriggerEvent,
  TriggerNode,
  Step,
} from '@/features/pipelines/schemas/nodes';
import { PipelineEdge } from '@/features/pipelines/schemas/edges';
import { Job, Jobs, Trigger } from './schemas/nodes';
import { Workflow } from './schemas/workflow';
import { Document } from 'yaml';

/**
 * Pipeline to GitHub Actions workflow converter
 */
export class PipelineWorkflowConverter {
  /**
   * Convert pipeline nodes and edges to GitHub Actions workflow YAML format
   */
  public convertToWorkflowYaml(nodes: PipelineNode[], edges: PipelineEdge[]): string {
    const workflow = this.buildWorkflowStructure(nodes, edges);

    const yaml = new Document();
    yaml.contents = yaml.createNode(workflow);
    yaml.commentBefore = 'Generated by Reposible';
    return yaml.toString();
  }

  /**
   * Build the workflow structure from nodes and edges
   */
  private buildWorkflowStructure(nodes: PipelineNode[], edges: PipelineEdge[]): Workflow {
    const triggerNodes = this.filterNodesByType(nodes, 'triggerNode');
    const jobNodes = this.filterNodesByType(nodes, 'jobNode');

    const workflow: Workflow = {
      name: 'Generated Pipeline',
      on: this.buildTriggers(triggerNodes),
      jobs: this.buildJobs(jobNodes, edges),
    };

    return workflow;
  }

  /**
   * Filter nodes by type(s)
   */
  private filterNodesByType<T extends PipelineNode['type']>(
    nodes: PipelineNode[],
    types: T | T[]
  ): Extract<PipelineNode, { type: T }>[] {
    const typeArray = Array.isArray(types) ? types : [types];
    return nodes.filter((node): node is Extract<PipelineNode, { type: T }> =>
      typeArray.includes(node.type as T)
    );
  }

  /**
   * Build trigger configuration from trigger nodes
   */
  private buildTriggers(triggerNodes: Extract<PipelineNode, TriggerNode>[]) {
    const triggers: Trigger = {};

    triggerNodes.forEach((trigger) => {
      if (trigger.data.event === TriggerEvent.Push) {
        const branches = this.ensureArray(trigger.data.branches);
        if (branches.length > 0) {
          triggers.push = { branches };
        } else {
          triggers.push = {}; // No branches means all branches
        }
      } else if (trigger.data.event === TriggerEvent.PullRequest) {
        const branches = this.ensureArray(trigger.data.branches);
        if (branches.length > 0) {
          triggers.pull_request = { branches };
        } else {
          triggers.pull_request = {}; // No branches means all branches
        }
      } else {
        throw new Error(`Unsupported trigger event: ${trigger.data.event}`);
      }
    });

    return triggers;
  }

  /**
   * Ensure branches is always a proper array of strings
   */
  private ensureArray(value: string[] | string | undefined): string[] {
    if (!value) return [];

    if (Array.isArray(value)) {
      // Handle array that might contain comma-separated strings
      return value.flatMap((item) =>
        typeof item === 'string'
          ? item
              .split(/,\s*/)
              .map((s) => s.trim())
              .filter(Boolean)
          : []
      );
    }

    if (typeof value === 'string') {
      // Handle comma-separated string
      return value
        .split(/,\s*/)
        .map((s) => s.trim())
        .filter(Boolean);
    }

    return [];
  }

  /**
   * Build jobs configuration from job nodes
   */
  private buildJobs(jobNodes: Extract<PipelineNode, JobNode>[], edges: PipelineEdge[]) {
    const jobs: Jobs = {};
    const usedJobNames = new Set<string>();

    // Process each job
    jobNodes.forEach((jobNode) => {
      const job: Job = {
        'runs-on': jobNode.data['runs-on'],
        steps: this.buildSteps(jobNode.data.steps),
      };

      // Add dependencies if this job depends on other jobs
      const dependencies = this.findJobDependencies(jobNode.id, jobNodes, edges);
      if (dependencies.length > 0) {
        // TypeScript workaround: needs is a valid GitHub Actions property but not in our schema
        (job as any).needs = dependencies;
      }

      // Validate job name uniqueness
      const jobName = this.validateJobName(jobNode.data.name, usedJobNames);
      usedJobNames.add(jobName);
      jobs[jobName] = job;
    });

    return jobs;
  }

  /**
   * Build steps array from job step data
   */
  private buildSteps(steps: Step[]) {
    return steps.map((step) => {
      if ('run' in step) {
        // Run step
        const runStep: any = { run: step.run };
        if (step.name) {
          runStep.name = step.name;
        }
        return runStep;
      } else if ('uses' in step) {
        // Action step
        const actionStep: any = { uses: step.uses };
        if (step.name) {
          actionStep.name = step.name;
        }
        return actionStep;
      }
      throw new Error(`Invalid step type: ${JSON.stringify(step)}`);
    });
  }

  /**
   * Find job dependencies by looking at edges
   */
  private findJobDependencies(
    jobId: string,
    jobNodes: Extract<PipelineNode, JobNode>[],
    edges: PipelineEdge[]
  ): string[] {
    const jobNodeIds = new Set(jobNodes.map((node) => node.id));
    
    // Find edges that point to this job from other jobs
    const dependencies = edges
      .filter((edge) => edge.target === jobId && jobNodeIds.has(edge.source))
      .map((edge) => {
        const sourceJob = jobNodes.find((job) => job.id === edge.source);
        if (!sourceJob) return null;
        return sourceJob.data.name.toLowerCase();
      })
      .filter((name): name is string => name !== null);

    return [...new Set(dependencies)]; // Remove duplicates
  }

  /**
   * Validate job name and ensure it's unique
   */
  private validateJobName(jobName: string, usedNames: Set<string>): string {
    // Check if name is empty
    if (!jobName || jobName.trim() === '') {
      throw new Error('Job name cannot be empty. Please provide a valid job name.');
    }

    // Check for invalid characters (GitHub Actions allows letters, numbers, hyphens, and underscores)
    const invalidCharacters = /[^a-zA-Z0-9_-]/;
    if (invalidCharacters.test(jobName)) {
      const firstInvalidChar = jobName.match(invalidCharacters)?.[0];
      throw new Error(
        `Job name "${jobName}" contains invalid character "${firstInvalidChar}". Only letters, numbers, hyphens, and underscores are allowed.`
      );
    }

    // Convert to lowercase for GitHub Actions compatibility
    const normalizedName = jobName.toLowerCase();

    // Check for uniqueness
    if (usedNames.has(normalizedName)) {
      throw new Error(
        `Duplicate job name "${normalizedName}" detected. Job names must be unique within a workflow.`
      );
    }

    return normalizedName;
  }

}
