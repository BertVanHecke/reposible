import {
  JobNode,
  PipelineNode,
  RunNode,
  TriggerEvent,
  TriggerNode,
  UsesNode,
} from '@/features/pipelines/schemas/nodes';
import { PipelineEdge } from '@/features/pipelines/schemas/edges';
import { Job, Jobs, RunStep, Trigger, UsesStep } from './schemas/nodes';
import { Workflow } from './schemas/workflow';
import { Document } from 'yaml';

/**
 * Pipeline to GitHub Actions workflow converter
 */
export class PipelineWorkflowConverter {
  /**
   * Convert pipeline nodes and edges to GitHub Actions workflow YAML format
   */
  public convertToWorkflowYaml(nodes: PipelineNode[], edges: PipelineEdge[]): string {
    const workflow = this.buildWorkflowStructure(nodes, edges);

    const yaml = new Document();
    yaml.contents = yaml.createNode(workflow);
    yaml.commentBefore = 'Generated by Reposible';
    return yaml.toString();
  }

  /**
   * Build the workflow structure from nodes and edges
   */
  private buildWorkflowStructure(nodes: PipelineNode[], edges: PipelineEdge[]): Workflow {
    const triggerNodes = this.filterNodesByType(nodes, 'triggerNode');
    const jobNodes = this.filterNodesByType(nodes, 'jobNode');
    const stepNodes = this.filterNodesByType(nodes, ['runNode', 'usesNode']);

    const workflow: Workflow = {
      name: 'Generated Pipeline',
      on: this.buildTriggers(triggerNodes),
      jobs: this.buildJobs(jobNodes, stepNodes, edges),
    };

    return workflow;
  }

  /**
   * Filter nodes by type(s)
   */
  private filterNodesByType<T extends PipelineNode['type']>(
    nodes: PipelineNode[],
    types: T | T[]
  ): Extract<PipelineNode, { type: T }>[] {
    const typeArray = Array.isArray(types) ? types : [types];
    return nodes.filter((node): node is Extract<PipelineNode, { type: T }> =>
      typeArray.includes(node.type as T)
    );
  }

  /**
   * Build trigger configuration from trigger nodes
   */
  private buildTriggers(triggerNodes: Extract<PipelineNode, TriggerNode>[]) {
    const triggers: Trigger = {};

    triggerNodes.forEach((trigger) => {
      if (trigger.data.event === TriggerEvent.Push) {
        const branches = this.ensureArray(trigger.data.branches);
        if (branches.length > 0) {
          triggers.push = { branches };
        } else {
          triggers.push = {}; // No branches means all branches
        }
      } else if (trigger.data.event === TriggerEvent.PullRequest) {
        const branches = this.ensureArray(trigger.data.branches);
        if (branches.length > 0) {
          triggers.pull_request = { branches };
        } else {
          triggers.pull_request = {}; // No branches means all branches
        }
      } else {
        throw new Error(`Unsupported trigger event: ${trigger.data.event}`);
      }
    });

    return triggers;
  }

  /**
   * Ensure branches is always a proper array of strings
   */
  private ensureArray(value: string[] | string | undefined): string[] {
    if (!value) return [];
    
    if (Array.isArray(value)) {
      // Handle array that might contain comma-separated strings
      return value.flatMap(item => 
        typeof item === 'string' 
          ? item.split(/,\s*/).map(s => s.trim()).filter(Boolean)
          : []
      );
    }
    
    if (typeof value === 'string') {
      // Handle comma-separated string
      return value.split(/,\s*/).map(s => s.trim()).filter(Boolean);
    }
    
    return [];
  }

  /**
   * Build jobs configuration from job and step nodes
   */
  private buildJobs(
    jobNodes: Extract<PipelineNode, JobNode>[],
    stepNodes: Extract<PipelineNode, RunNode | UsesNode>[],
    edges: PipelineEdge[]
  ) {
    const jobs: Jobs = {};
    const usedJobNames = new Set<string>();

    // Process each job
    jobNodes.forEach((jobNode) => {
      const connectedSteps = this.getConnectedSteps(jobNode.id, stepNodes, edges);

      const job: Job = {
        'runs-on': jobNode.data['runs-on'],
      };

      if (connectedSteps.length > 0) {
        job.steps = this.convertStepsToJobSteps(connectedSteps);
      }

      // Validate job name uniqueness
      const jobName = this.validateJobName(jobNode.data.name, usedJobNames);
      usedJobNames.add(jobName);
      jobs[jobName] = job;
    });

    return jobs;
  }

  /**
   * Validate job name and ensure it's unique
   */
  private validateJobName(jobName: string, usedNames: Set<string>): string {
    // Check if name is empty
    if (!jobName || jobName.trim() === '') {
      throw new Error('Job name cannot be empty. Please provide a valid job name.');
    }

    // Check for invalid characters (GitHub Actions allows letters, numbers, hyphens, and underscores)
    const invalidCharacters = /[^a-zA-Z0-9_-]/;
    if (invalidCharacters.test(jobName)) {
      const firstInvalidChar = jobName.match(invalidCharacters)?.[0];
      throw new Error(`Job name "${jobName}" contains invalid character "${firstInvalidChar}". Only letters, numbers, hyphens, and underscores are allowed.`);
    }

    // Convert to lowercase for GitHub Actions compatibility
    const normalizedName = jobName.toLowerCase();

    // Check for uniqueness
    if (usedNames.has(normalizedName)) {
      throw new Error(`Duplicate job name "${normalizedName}" detected. Job names must be unique within a workflow.`);
    }

    return normalizedName;
  }

  /**
   * Get all steps connected to a job (steps that execute within this job only)
   */
  private getConnectedSteps(
    jobId: string,
    stepNodes: (RunNode | UsesNode)[],
    edges: PipelineEdge[]
  ) {
    const jobSteps: (RunNode | UsesNode)[] = [];
    const allJobIds = new Set(this.getAllJobIds(edges));

    // Find steps directly connected to this job
    const directSteps = stepNodes.filter((step) =>
      edges.some((edge) => edge.source === jobId && edge.target === step.id)
    );

    // For each direct step, follow the execution chain until we hit a job boundary
    const visitedGlobally = new Set<string>();
    directSteps.forEach((step) => {
      this.collectStepsInJobChain(step, stepNodes, edges, jobSteps, visitedGlobally, allJobIds);
    });

    // Sort steps to maintain execution order
    return this.sortStepsByExplicitOrder(jobSteps, edges)
  }

  /**
   * Get all job IDs from the edges to help identify job boundaries
   */
  private getAllJobIds(edges: PipelineEdge[]): string[] {
    const jobIds = new Set<string>();
    edges.forEach((edge) => {
      if (edge.source.startsWith('job-')) jobIds.add(edge.source);
      if (edge.target.startsWith('job-')) jobIds.add(edge.target);
    });
    return Array.from(jobIds);
  }

  /**
   * Collect steps that belong to this job by following execution chains until job boundaries
   */
  private collectStepsInJobChain(
    currentStep: RunNode | UsesNode,
    stepNodes: (RunNode | UsesNode)[],
    edges: PipelineEdge[],
    jobSteps: (RunNode | UsesNode)[],
    visitedGlobally: Set<string>,
    allJobIds: Set<string>
  ): void {
    // Don't process already visited steps (prevents infinite loops and double-counting)
    if (visitedGlobally.has(currentStep.id)) {
      return;
    }

    visitedGlobally.add(currentStep.id);

    // Check if this step connects to another job
    const connectsToJob = edges.some(
      (edge) => edge.source === currentStep.id && allJobIds.has(edge.target)
    );

    // This step belongs to the current job
    jobSteps.push(currentStep);

    // If this step connects to another job, stop here (this is the boundary)
    if (connectsToJob) {
      return;
    }

    // Find next steps in the execution chain
    const nextSteps = stepNodes.filter(
      (step) =>
        !visitedGlobally.has(step.id) &&
        edges.some((edge) => edge.source === currentStep.id && edge.target === step.id)
    );

    // Continue following the chain for each next step
    nextSteps.forEach((nextStep) => {
      this.collectStepsInJobChain(nextStep, stepNodes, edges, jobSteps, visitedGlobally, allJobIds);
    });
  }

  /**
   * Sort steps by explicit order values with validation
   */
  private sortStepsByExplicitOrder(
    steps: (RunNode | UsesNode)[],
    edges: PipelineEdge[]
  ): (RunNode | UsesNode)[] {
    // Separate steps with and without explicit order
    const stepsWithOrder = steps.filter(step => step.data.order !== undefined);
    const stepsWithoutOrder = steps.filter(step => step.data.order === undefined);
    
    // Check for duplicate order values
    const orderValues = stepsWithOrder.map(step => step.data.order!);
    const duplicateOrders = orderValues.filter((order, index) => orderValues.indexOf(order) !== index);
    
    if (duplicateOrders.length > 0) {
      throw new Error(`Duplicate step order values found: ${duplicateOrders.join(', ')}. Each step must have a unique order value.`);
    }
    
    // Sort steps with explicit order
    const sortedWithOrder = stepsWithOrder.sort((a, b) => a.data.order! - b.data.order!);
    
    // For steps without order, use topological sort and append them
    const sortedWithoutOrder = stepsWithoutOrder.length > 0 
      ? this.sortStepsByTopology(stepsWithoutOrder, edges)
      : [];
    
    // Validate that explicit ordering doesn't conflict with edge dependencies
    this.validateOrderAgainstDependencies([...sortedWithOrder, ...sortedWithoutOrder], edges);
    
    return [...sortedWithOrder, ...sortedWithoutOrder];
  }

  /**
   * Sort steps using topological sort based on edge dependencies
   */
  private sortStepsByTopology(
    steps: (RunNode | UsesNode)[],
    edges: PipelineEdge[]
  ): (RunNode | UsesNode)[] {
    // Simple topological sort for steps within this job
    const sorted: (RunNode | UsesNode)[] = [];
    const visited = new Set<string>();
    const stepIds = new Set(steps.map((s) => s.id));

    const visit = (step: RunNode | UsesNode) => {
      if (visited.has(step.id)) return;
      visited.add(step.id);

      // Find dependencies (incoming edges from other steps in this job)
      const dependencies = steps.filter((s) =>
        edges.some((edge) => edge.source === s.id && edge.target === step.id)
      );

      dependencies.forEach((dep) => visit(dep));
      sorted.push(step);
    };

    // Start with steps that have no dependencies within this job
    const rootSteps = steps.filter(
      (step) => !edges.some((edge) => edge.target === step.id && stepIds.has(edge.source))
    );

    rootSteps.forEach((step) => visit(step));

    // Add any remaining steps
    steps.forEach((step) => visit(step));

    return sorted;
  }

  /**
   * Validate that explicit ordering doesn't conflict with edge dependencies
   */
  private validateOrderAgainstDependencies(
    sortedSteps: (RunNode | UsesNode)[],
    edges: PipelineEdge[]
  ): void {
    const stepPositions = new Map<string, number>();
    sortedSteps.forEach((step, index) => {
      stepPositions.set(step.id, index);
    });

    // Check each edge to ensure dependencies are satisfied
    for (const edge of edges) {
      const sourcePos = stepPositions.get(edge.source);
      const targetPos = stepPositions.get(edge.target);
      
      if (sourcePos !== undefined && targetPos !== undefined && sourcePos >= targetPos) {
        const sourceStep = sortedSteps.find(s => s.id === edge.source);
        const targetStep = sortedSteps.find(s => s.id === edge.target);
        throw new Error(
          `Step ordering conflict: Step "${targetStep?.data.name || targetStep?.id}" (order ${targetStep?.data.order || 'auto'}) ` +
          `depends on step "${sourceStep?.data.name || sourceStep?.id}" (order ${sourceStep?.data.order || 'auto'}), ` +
          `but the dependency comes after it in the execution order.`
        );
      }
    }
  }

  /**
   * Convert step nodes to GitHub Actions job steps format
   */
  private convertStepsToJobSteps(stepNodes: (RunNode | UsesNode)[]): (RunStep | UsesStep)[] {
    return stepNodes.map((step) => {
      if (step.type === 'usesNode') {
        return this.buildUsesStep(step);
      } else if (step.type === 'runNode') {
        return this.buildRunStep(step);
      } else {
        throw new Error(`Unsupported step: ${JSON.stringify(step)}`);
      }
    });
  }

  /**
   * Build a 'uses' step
   */
  private buildUsesStep(step: UsesNode): UsesStep {
    const stepData: UsesStep = {
        uses: step.data.uses
    }

    if (step.data.name) {
      stepData.name = step.data.name;
    }

    if (step.data.with && Object.keys(step.data.with).length > 0) {
      stepData.with = step.data.with;
    }

    return stepData;
  }

  /**
   * Build a 'run' step
   */
  private buildRunStep(step: RunNode): RunStep {
    const stepData: RunStep = {
      run: step.data.run
    };

    if (step.data.name) {
      stepData.name = step.data.name;
    }

    return stepData;
  }
}
